
**Commençons notre premier projet, un système d’éclairage.**

--------------

Allumer une LED est l’un des exercices Arduino les plus fondamentaux.

Cette leçon d’introduction est conçue pour les débutants afin de comprendre le matériel et la programmation logicielle sur la carte de développement ESP32 et d’acquérir les connaissances de base en circuits et en programmation.

.. image:: ./scratch_img/cout1.png
   :alt: img

Ainsi, nos instructions sont simples. Et ce projet stimulant peut être appliqué à la maison ou au bureau.

Dans ce projet, vous apprendrez les connexions et réglages de base de la carte ESP32 dans la programmation Arduino. De plus, certaines fonctions vous seront présentées, comme allumer/éteindre une LED via le niveau de sortie d’une broche numérique ou par un bouton.

En somme, il s’agit d’un tutoriel de niveau débutant pour poser les bases des pratiques Arduino ultérieures.

--------------

1.1 Schéma de flux
^^^^^^^^^^^^^^^^^^

.. image:: ./scratch_img/image-20230607175228556.png
   :alt: image-20230607175228556

--------------

1.2 Allumer une LED
^^^^^^^^^^^^^^^^^^^

**Description :**

LED, abréviation de "Light Emitting Diode" (diode électroluminescente), est un semi-conducteur à l’état solide qui convertit l’énergie électrique en lumière visible, d’où le nom d’éclairage à semi-conducteurs.

Lorsque le courant traverse une LED, elle s’allume.

**Différents types de LED :**

.. image:: ./scratch_img/cou1.png
   :alt: img

--------------

Le **module LED** est un dispositif de sortie dont la luminosité et les clignotements peuvent être contrôlés. Pour l’utiliser, il suffit de le brancher directement sur les broches de sortie numérique de la carte de développement.

.. image:: ./scratch_img/cou12.png
   :alt: img

--------------

**Principe de fonctionnement :**

Quand S est à un niveau haut, le transistor Q1 conduit, et la tension VCC traverse la LED pour l’allumer.

.. image:: ./scratch_img/couy1.png
   :alt: img

**Paramètres :**

- Tension : 3~5V
- Courant : ≤1.5mA
- Puissance : 0.07W

--------------

**Schéma de câblage :**

**Connectez le module LED à io27.**

**Attention : Connectez le fil jaune à S (Signal), le rouge à V (Alimentation), et le noir à GND. Ne les inversez pas !**

.. image:: ./scratch_img/couj1.png
   :alt: img

--------------

**Code de test :**

- Ouvrez Kidsblock et choisissez le bon appareil et port.

   .. image:: ./scratch_img/st1.png
      :alt: img

- Faites glisser |image19| depuis |image20| dans la zone d’édition du code. Les blocs de code ne s’exécutent que lorsqu’ils sont dans cette zone.

   .. image:: ./scratch_img/st12.png
      :alt: img

- Avec ce bloc, au démarrage de la carte, le code s’exécutera.

   .. image:: ./scratch_img/st11.png
      :alt: img

- Dans |image21|, faites glisser “**forever**” et placez-le sous le bloc précédent. Le bloc “**forever**” indique une boucle.

   .. image:: ./scratch_img/st20.png
      :alt: img

- Faites glisser un bloc "**Sortie de la broche LED**" depuis |image22| et placez-le dans “**forever**”. Réglez la broche sur IO27 et le niveau de sortie sur HIGH, la LED restera donc allumée.

.. image:: ./scratch_img/st21.png
   :alt: img

.. image:: ./scratch_img/st22-1.png
   :alt: img

- Ajoutez un délai d’1 seconde. Dupliquez le bloc "**Sortie de la broche LED**" mais réglez la sortie sur LOW, puis ajoutez également un délai. Ainsi, la LED s’allumera et s’éteindra en boucle.

   .. image:: ./scratch_img/st22.png
      :alt: img

**Résultat du test :**

La LED clignote chaque seconde, car io27 sur la carte ESP32 alterne entre un niveau haut et bas toutes les secondes. De plus, diverses applications interactives peuvent être réalisées via une LED, telles que la LED respirante, les lumières "water flow" et les gyrophares.

.. container:: table-wrapper

=========== =======
Niveau      Résultat
=========== =======
HIGH        LED allumée
LOW         LED éteinte
=========== =======

--------------

**Extension : LED respirante**

**Description :**

Les interfaces IO des MCU (arduino UNO, ESP32 et Raspberry Pi Pico) n’émettent que des signaux numériques (haut ou bas). Par exemple, dans l’expérience précédente (allumer une LED), les sorties numériques sont uniquement HIGH (3.3V) et LOW (0V).

Si le MCU fournit un niveau haut de 3.3V ou un niveau bas de 0V, la tension d’entrée doit être comprise entre 0~3.3V. Ainsi, le PWM (**Modulation de largeur d’impulsion**) est nécessaire pour générer différentes valeurs de tension, ce qu’on appelle la "sortie analogique".

.. image:: ./scratch_img/cou1k1.png
   :alt: img

--------------

**Connaissances :**

Qu’est-ce que le PWM ?

Le PWM comporte trois éléments : Fréquence (Hz), Période, Rapport cyclique (%).

- **Fréquence PWM (f) :** nombre de changements du signal de haut en bas et retour à haut en une seconde. En général, la fréquence est le nombre de périodes PWM par seconde.

- **Période PWM (T) :** Période = 1 / Fréquence (T=1/f, et 1 signifie 1 seconde). Par exemple : f = 50Hz, donc T = 20ms, ce qui implique 50 périodes par seconde.

- **Rapport cyclique PWM :** ratio du temps haut sur la totalité de la période. Si la période = 10ms et le temps d’impulsion est de 8ms, le niveau bas occupe 2ms, donc le rapport cyclique = 8/(8+2) = 80%.

.. image:: ./scratch_img/cou1k2.png
   :alt: img

**Conclusion : À une fréquence de signal appropriée, le PWM modifie la tension de sortie effective en changeant le rapport cyclique pendant une période.** En termes simples, plus la broche IO reste à un niveau haut dans un temps donné, plus la valeur PWM est élevée, et plus la LED sera lumineuse.

.. image:: ./scratch_img/cou1k3.png
   :alt: img

**Code de test :**

.. image:: ./scratch_img/st23.png
   :alt: img

- Définissez une variable **item** et affectez-lui la valeur 0.

   .. image:: ./scratch_img/st25.png
      :alt: img

- Faites glisser un bloc "**forever**" et placez un bloc "**repeat**" à l’intérieur. Réglez le nombre de répétitions à 255.

   .. image:: ./scratch_img/st26.png
      :alt: img

- Faites glisser un bloc "**mode variable**" dans "**repeat**" et réglez le mode sur “**++**”, ce qui signifie que **item** augmente de 1 à chaque exécution.

   .. image:: ./scratch_img/st27.png
      :alt: img

- Trouvez le bloc pour régler le PWM qui se trouve dans |image23| comme ci-dessous, il suffit de régler la broche et la valeur analogique pour générer du PWM.

   .. image:: ./scratch_img/st28.png
      :alt: img

   - Réglez la broche LED :

      .. image:: ./scratch_img/st29.png
         :alt: img

   - Réglez le canal : (16 canaux au total : 0~15)

      .. image:: ./scratch_img/st30.png
         :alt: img

   - Réglez la valeur PWM à **item**, qui augmentera automatiquement de 0 à 255. **PWM sort de 0~255, donc on répète 255 fois.**

      .. image:: ./scratch_img/st31.png
         :alt: img

- Ajoutez un délai de 0.01s, pour que la LED s’allume progressivement au lieu de s’allumer d’un coup.

   .. image:: ./scratch_img/st32.png
      :alt: img

- Dupliquez le bloc "**repeat**" comme ci-dessous, mais réglez le mode sur "**－－**", ce qui diminue la variable **item** à chaque fois. Ainsi, la LED s’éteindra progressivement.

   .. image:: ./scratch_img/st33.png
      :alt: img

**Résultat du test**

La LED s’allume et s’éteint progressivement ; elle "respire" de façon régulière.

.. image:: ./scratch_img/st3gif
   :alt: img

--------------

1.4 Un bouton
^^^^^^^^^^^^^

**Description**

Le **module bouton** est un dispositif d’entrée. Le MCU lit son niveau pour détecter si le bouton est pressé.

.. image:: ./scratch_img/cou13.png
   :alt: img

--------------

**Schéma électronique :**

.. image:: ./scratch_img/couy12.png
   :alt: img

**Paramètres :**

- Tension : 3~5V
- Courant : ≤1.1mA
- Puissance : ≤5.5mW

--------------

**Le principe du module bouton est un circuit contrôlé par ce bouton.**

- **Quand le bouton est pressé**, le circuit est fermé, le courant passe par le bouton vers GND, ce qui fait que la broche d’entrée numérique détecte un niveau bas.
- **Quand le bouton est relâché**, le circuit est ouvert et le niveau de la broche augmente grâce à une résistance de pull-up, ce qui fait que la broche numérique détecte un niveau haut.

--------------

**Schéma de câblage :**

**Connectez le module bouton à io5**

**Attention : Connectez le fil jaune à S (Signal), le rouge à V (Alimentation), et le noir à GND. Ne les inversez pas !**

.. image:: ./scratch_img/couj12.png
   :alt: img

--------------

**Code de test**

- Initialisez d’abord le port série et réglez le débit à 115200.

   .. image:: ./scratch_img/st36.png
      :alt: img

- Réglez la broche sur IO5 et le mode sur entrée. Ensuite, placez un bloc "**forever**".

   .. image:: ./scratch_img/st37.png
      :alt: img

- Lisez le niveau de la broche numérique 5. Si c’est 1, affichez 1. Sinon, affichez 0.

   .. image:: ./scratch_img/st38.png
      :alt: img

Code complet :

.. image:: ./scratch_img/st35.png
   :alt: img

**Résultat du test**

Ouvrez le moniteur série et sélectionnez le débit correspondant.

Quand le bouton est relâché, la valeur est 1 ; si vous appuyez sur le bouton, elle devient 0.

.. image:: ./scratch_img/st39.png
   :alt: img

Dans KidsBlock, on peut lire l’état de la broche d’entrée numérique par programmation pour détecter si le bouton est pressé. Ainsi, de nombreuses applications interactives peuvent être réalisées avec un module bouton, comme allumer/éteindre une LED ou ajuster la luminosité d’un écran.

--------------

**Extension : Bouton à verrouillage automatique**

Un bouton à verrouillage automatique ne revient pas à sa position initiale quand vous appuyez dessus sans maintenir, et il ne remonte que si vous appuyez à nouveau. Il fonctionne comme un interrupteur. Pour les boutons ordinaires, cette fonction peut être réalisée via le MCU et le logiciel.

**Code de test**

- Définir deux variables : **item** comme valeur lue du bouton et **button** comme valeur basculée par le bouton.

   .. image:: ./scratch_img/st40.png
      :alt: img

- Affectez la valeur lue du bouton à **item**.

   .. image:: ./scratch_img/st41.png
      :alt: img

- Déterminez si le bouton est pressé. Si oui, basculez la valeur de **button** et affichez-la.

   .. image:: ./scratch_img/st43.png
      :alt: img

   - Délai de 0.01s pour éliminer le rebond du bouton.

      - Si un état fermé est détecté sur le bouton, un délai sera exécuté pour éliminer le rebond avant front. Généralement, ce délai est compris entre 5ms et 10ms (propriétés mécaniques). Après disparition du rebond, vérifiez à nouveau l’état du bouton. Si l’état fermé persiste, il est confirmé que le bouton est pressé.
      - Lorsqu’un bouton relâché est détecté, un délai de 5ms à 10ms doit également être appliqué pour éliminer le rebond arrière, afin que le programme du bouton puisse être exécuté.

- Quand le bouton est pressé, **button** vaut 1. Appuyez à nouveau, **button** passe à 0, alternativement.

Code complet :

.. image:: ./scratch_img/st4png
   :alt: img

**Résultat du test**

Chargez le code et ouvrez le moniteur série.

Quand vous appuyez une fois, 1 s’affiche. Si vous appuyez une seconde fois, la valeur devient 0. Ainsi, un bouton ordinaire peut fonctionner comme un bouton à verrouillage automatique.

.. image:: ./scratch_img/st46.png
   :alt: img

--------------

1.3 Contrôle de l’éclairage
^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Description**

Dans les expériences de base ci-dessus, nous avons modifié un bouton à verrouillage automatique pour contrôler la LED. Un bouton à verrouillage automatique est adapté à toutes les situations où un certain état doit être maintenu, par exemple, pour garder une LED allumée longtemps, la carte ESP32 est requise pour certaines opérations.

Dans cette expérience, nous utiliserons la carte Arduino ESP32 pour vous guider dans la réalisation d’un système d’éclairage et simuler des scénarios réels pour contrôler la lumière via le bouton.

--------------

**Schéma de câblage :**

**Connectez le bouton à io5 et la LED à io27**

**Attention : Connectez le fil jaune à S (Signal), le rouge à V (Alimentation), et le noir à GND. Ne les inversez pas !**

.. image:: ./scratch_img/couj13.png
   :alt: img

--------------

**Code de test :**

Flux du code :

.. image:: ./scratch_img/flo1.png
   :alt: img

Code complet :

Sur la base du code pour le bouton à verrouillage automatique, nous ajoutons des blocs "**Sortie de la broche LED**".

.. image:: ./scratch_img/st47.png
   :alt: img

**Résultat du test :**

**Lorsque vous appuyez une fois sur le bouton, la LED s’allume ; si vous appuyez à nouveau, la LED s’éteint. Cette opération boucle, conformément au principe d’éclairage réel.**

--------------

Dans ce chapitre, nous avons montré comment programmer et contrôler via KidsBlock, et nous avons appris les bases ainsi que des concepts logiciels et matériels dans des expériences comme le bouton à verrouillage automatique et le système de contrôle de l’éclairage.

Ces notions sont essentielles pour un bon développeur KidsBlock. Ensuite, nous vous guiderons pour explorer davantage d’applications et de compétences, que vous soyez débutant ou expérimenté. Profitez du plaisir et des défis lors de l’apprentissage de KidsBlock. Continuons !

--------------

1.5 FAQ
^^^^^^^

**Q : La LED ne s’allume pas après l’envoi du code.**

R : Veuillez vérifier si la broche définie dans le code correspond à celle de votre câblage. Si ce n’est pas le cas, ajustez-la en vous référant au code.

--------------

**Q : Le bouton fonctionne parfois, parfois non.**

R : Veuillez modifier la durée du délai pour l’élimination du rebond à une valeur appropriée.

.. code:: c++

    //Éliminer le rebond du bouton
      delay(10);  //Modifiez la valeur de délai sur cette ligne

---

N'hésitez pas à demander si vous souhaitez la traduction d’une autre partie ou des précisions !
